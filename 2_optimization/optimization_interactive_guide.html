<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimization Methods: An Interactive Guide</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        /* Distill.pub inspired styles */
        :root {
            --distill-text: #1a1a1a;
            --distill-gray: #666;
            --distill-light-gray: #e8e8e8;
            --distill-blue: #004e89;
            --distill-accent: #ff6b35;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Pro', 'Georgia', serif;
            font-size: 20px;
            line-height: 1.65;
            color: var(--distill-text);
            background: #fff;
            -webkit-font-smoothing: antialiased;
        }

        /* Typography */
        h1, h2, h3, h4 {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 700;
            line-height: 1.2;
            margin-top: 2em;
            margin-bottom: 0.5em;
        }

        h1 {
            font-size: 3em;
            margin-top: 0.5em;
            margin-bottom: 0.3em;
            letter-spacing: -0.02em;
        }

        h2 {
            font-size: 2em;
            margin-top: 2em;
            border-bottom: 2px solid var(--distill-light-gray);
            padding-bottom: 0.3em;
        }

        h3 {
            font-size: 1.5em;
            color: var(--distill-blue);
        }

        /* Layout */
        .article-header {
            max-width: 760px;
            margin: 0 auto;
            padding: 60px 20px 40px;
            text-align: center;
        }

        .article-meta {
            font-family: 'Inter', sans-serif;
            font-size: 0.9em;
            color: var(--distill-gray);
            margin-top: 1em;
        }

        .article-meta strong {
            color: var(--distill-text);
        }

        .article-content {
            max-width: 760px;
            margin: 0 auto;
            padding: 20px;
        }

        .full-width {
            width: 100vw;
            position: relative;
            left: 50%;
            right: 50%;
            margin-left: -50vw;
            margin-right: -50vw;
            padding: 40px 20px;
            background: #fafafa;
        }

        .full-width-inner {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Interactive elements */
        .interactive-demo {
            background: white;
            border: 1px solid var(--distill-light-gray);
            border-radius: 8px;
            padding: 30px;
            margin: 2em 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .demo-title {
            font-family: 'Inter', sans-serif;
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 1em;
            color: var(--distill-blue);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
            font-family: 'Inter', sans-serif;
            font-size: 0.85em;
        }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--distill-gray);
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--distill-light-gray);
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--distill-blue);
            cursor: pointer;
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--distill-blue);
            cursor: pointer;
            border: none;
        }

        .control-group .value-display {
            display: inline-block;
            margin-left: 10px;
            color: var(--distill-blue);
            font-weight: 600;
        }

        button {
            font-family: 'Inter', sans-serif;
            background: var(--distill-blue);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #003d6b;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,78,137,0.3);
        }

        button:active {
            transform: translateY(0);
        }

        /* Code blocks */
        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            font-family: 'Fira Code', 'Monaco', monospace;
            font-size: 0.85em;
            line-height: 1.5;
            margin: 1.5em 0;
        }

        .code-block .keyword { color: #c678dd; }
        .code-block .function { color: #61afef; }
        .code-block .string { color: #98c379; }
        .code-block .comment { color: #5c6370; font-style: italic; }
        .code-block .number { color: #d19a66; }

        /* Callouts */
        .callout {
            background: #f0f7ff;
            border-left: 4px solid var(--distill-blue);
            padding: 20px;
            margin: 2em 0;
            border-radius: 4px;
        }

        .callout-title {
            font-family: 'Inter', sans-serif;
            font-weight: 700;
            color: var(--distill-blue);
            margin-bottom: 0.5em;
        }

        .warning {
            background: #fff5f0;
            border-left-color: var(--distill-accent);
        }

        .warning .callout-title {
            color: var(--distill-accent);
        }

        /* Figures */
        figure {
            margin: 2em 0;
        }

        figcaption {
            font-family: 'Inter', sans-serif;
            font-size: 0.85em;
            color: var(--distill-gray);
            margin-top: 0.5em;
            text-align: center;
        }

        /* Plot containers */
        .plot-container {
            margin: 2em 0;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            min-height: 500px;
            height: auto;
        }

        .plot-container > div {
            min-height: 500px !important;
            height: 500px !important;
        }

        /* Footer */
        footer {
            max-width: 760px;
            margin: 60px auto 40px;
            padding: 40px 20px;
            border-top: 2px solid var(--distill-light-gray);
            font-family: 'Inter', sans-serif;
            font-size: 0.85em;
            color: var(--distill-gray);
            text-align: center;
        }

        /* Responsive */
        @media (max-width: 768px) {
            body {
                font-size: 18px;
            }

            h1 {
                font-size: 2em;
            }

            h2 {
                font-size: 1.5em;
            }

            .controls {
                flex-direction: column;
            }
        }

        /* Math */
        .mjx-chtml {
            font-size: 1.1em !important;
        }

        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
        }

        /* Section numbers */
        .section-number {
            color: var(--distill-gray);
            font-weight: 400;
            margin-right: 0.5em;
        }
    </style>
</head>
<body>
    <header class="article-header">
        <h1>Optimization Methods: An Interactive Guide</h1>
        <div class="article-meta">
            <strong>Dr. Arun B Ayyar</strong><br>
            Indian Institute of Technology Madras<br>
            Course: DA5400W - Foundations of Machine Learning
        </div>
    </header>

    <article class="article-content">
        <section id="introduction">
            <p>
                Optimization is at the heart of machine learning. Whether we are training a neural network, 
                finding the best-fit line in a regression problem, or creating an optimal investment portfolio, 
                we are fundamentally trying to optimize an objective function. This interactive guide bridges 
                theoretical concepts with practical implementation, making these powerful techniques tangible 
                and accessible.
            </p>
        </section>

        <section id="fundamentals">
            <h2><span class="section-number">1.</span>Fundamentals of Optimization</h2>
            
            <h3>1.1 Linear Functions</h3>
            <p>
                A function \(f(x)\) is <strong>linear</strong> if it satisfies the superposition principle:
            </p>
            <p style="text-align: center; font-size: 1.1em; margin: 1.5em 0;">
                \[f(\alpha x_1 + \beta x_2) = \alpha f(x_1) + \beta f(x_2)\]
            </p>

            <div class="interactive-demo">
                <div class="demo-title">Interactive: Linear Function Visualization</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Coefficient c₁: <span class="value-display" id="c1-value">2</span></label>
                        <input type="range" id="c1-slider" min="-5" max="5" step="0.1" value="2">
                    </div>
                    <div class="control-group">
                        <label>Coefficient c₂: <span class="value-display" id="c2-value">3</span></label>
                        <input type="range" id="c2-slider" min="-5" max="5" step="0.1" value="3">
                    </div>
                </div>
                <div id="linear-plot" class="plot-container"></div>
            </div>

            <div class="callout">
                <div class="callout-title">Key Insight</div>
                <p>
                    Linear functions form flat planes in 3D space. The contour lines are parallel and evenly 
                    spaced, which is the geometric signature of linearity. These functions are the foundation 
                    of Linear Programming problems.
                </p>
            </div>

            <h3>1.2 Convex Functions</h3>
            <p>
                A function \(f(x)\) is <strong>convex</strong> if the line segment connecting any two points 
                on the function's graph lies on or above the graph itself:
            </p>
            <p style="text-align: center; font-size: 1.1em; margin: 1.5em 0;">
                \[f(\lambda x_1 + (1-\lambda)x_2) \leq \lambda f(x_1) + (1-\lambda)f(x_2), \quad \lambda \in [0,1]\]
            </p>

            <div class="interactive-demo">
                <div class="demo-title">Interactive: Convexity Test</div>
                <div class="controls">
                    <div class="control-group">
                        <label>λ (lambda): <span class="value-display" id="lambda-value">0.50</span></label>
                        <input type="range" id="lambda-slider" min="0" max="1" step="0.01" value="0.5">
                    </div>
                </div>
                <div id="convex-plot" class="plot-container"></div>
            </div>

            <div class="callout">
                <div class="callout-title">Why Convexity Matters</div>
                <p>
                    Convexity is crucial in optimization because it guarantees that any local minimum is also 
                    a global minimum. This makes convex optimization problems much easier to solve reliably.
                </p>
            </div>
        </section>

        <section id="unconstrained">
            <h2><span class="section-number">2.</span>Unconstrained Optimization</h2>
            
            <h3>2.1 Single-Variable Optimization</h3>
            <p>
                Consider the profit maximization problem from the lecture:
            </p>
            <p style="text-align: center; font-size: 1.1em; margin: 1.5em 0;">
                \[\max_{x} f(x) = 1000000 + 4000x - x^2\]
            </p>

            <div class="interactive-demo">
                <div class="demo-title">Interactive: Profit Maximization</div>
                <p>
                    The optimal solution occurs where the derivative equals zero. Using calculus:
                </p>
                <p style="text-align: center; margin: 1em 0;">
                    \[f'(x^*) = 4000 - 2x = 0 \implies x^* = 2000\]
                </p>
                <div id="profit-plot" class="plot-container"></div>
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="animateGradientDescent()">Animate Gradient Descent</button>
                </div>
            </div>

            <h3>2.2 Gradient Descent Visualization</h3>
            <p>
                Gradient descent is an iterative algorithm that moves in the direction of steepest descent 
                (negative gradient) to find a local minimum:
            </p>
            <p style="text-align: center; font-size: 1.1em; margin: 1.5em 0;">
                \[x_{k+1} = x_k - \eta \nabla f(x_k)\]
            </p>
            <p>
                where \(\eta\) is the learning rate.
            </p>

            <div class="interactive-demo">
                <div class="demo-title">Interactive: Gradient Descent on 2D Function</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Learning Rate η: <span class="value-display" id="lr-value">0.10</span></label>
                        <input type="range" id="lr-slider" min="0.01" max="0.5" step="0.01" value="0.1">
                    </div>
                    <div class="control-group">
                        <label>Start X: <span class="value-display" id="startx-value">0.0</span></label>
                        <input type="range" id="startx-slider" min="-2" max="2" step="0.1" value="0">
                    </div>
                    <div class="control-group">
                        <label>Start Y: <span class="value-display" id="starty-value">0.0</span></label>
                        <input type="range" id="starty-slider" min="-2" max="2" step="0.1" value="0">
                    </div>
                </div>
                <div style="text-align: center; margin: 20px 0;">
                    <button onclick="runGradientDescent()">Run Gradient Descent</button>
                    <button onclick="resetGradientDescent()" style="background: #666;">Reset</button>
                </div>
                <div id="gd-plot" class="plot-container"></div>
                <div id="gd-info" style="font-family: 'Inter', sans-serif; font-size: 0.9em; margin-top: 15px; text-align: center;"></div>
            </div>

            <div class="callout warning">
                <div class="callout-title">Learning Rate Selection</div>
                <p>
                    The learning rate is a critical hyperparameter. If it's too small, convergence is slow. 
                    If it's too large, the algorithm can overshoot the minimum and even diverge. Try different 
                    values in the demo above to see this effect!
                </p>
            </div>
        </section>

        <section id="linear-programming">
            <h2><span class="section-number">3.</span>Linear Programming</h2>
            
            <p>
                Linear Programming (LP) problems have a linear objective function and linear constraints. 
                A classic example is production optimization:
            </p>
            <p style="text-align: center; font-size: 1.1em; margin: 1.5em 0;">
                \[\begin{aligned}
                \max \quad & 3x_1 + 2x_2 \\
                \text{s.t.} \quad & 2x_1 + x_2 \leq 100 \\
                & x_1 + x_2 \leq 80 \\
                & x_1, x_2 \geq 0
                \end{aligned}\]
            </p>

            <div class="interactive-demo">
                <div class="demo-title">Interactive: Linear Programming Visualization</div>
                <div id="lp-plot" class="plot-container"></div>
            </div>

            <div class="callout">
                <div class="callout-title">Fundamental Theorem of Linear Programming</div>
                <p>
                    If an optimal solution exists, it will occur at a vertex (corner point) of the feasible 
                    region. This is why the simplex algorithm works by moving from vertex to vertex, always 
                    improving the objective function.
                </p>
            </div>
        </section>

        <section id="gradient-methods">
            <h2><span class="section-number">4.</span>Gradient Descent Variants</h2>
            
            <p>
                Modern machine learning relies heavily on gradient-based optimization. Let's explore the 
                main variants:
            </p>

            <h3>4.1 Batch vs Stochastic vs Mini-batch</h3>
            
            <div style="margin: 2em 0;">
                <table style="width: 100%; border-collapse: collapse; font-family: 'Inter', sans-serif; font-size: 0.9em;">
                    <thead>
                        <tr style="background: var(--distill-light-gray);">
                            <th style="padding: 12px; text-align: left; border: 1px solid #ddd;">Method</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #ddd;">Batch Size</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #ddd;">Characteristics</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Batch GD</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">All data</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">Slow but stable, smooth convergence</td>
                        </tr>
                        <tr style="background: #fafafa;">
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Stochastic GD</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">1 sample</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">Fast but noisy, erratic path</td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;"><strong>Mini-batch GD</strong></td>
                            <td style="padding: 12px; border: 1px solid #ddd;">32-256</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">Best balance, widely used</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>4.2 Advanced Optimizers</h3>
            
            <div class="interactive-demo">
                <div class="demo-title">Interactive: Optimizer Comparison</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Select Optimizer:</label>
                        <select id="optimizer-select" onchange="updateLearningRateControl()" style="width: 100%; padding: 8px; border: 1px solid var(--distill-light-gray); border-radius: 4px; font-family: 'Inter', sans-serif;">
                            <option value="sgd">SGD</option>
                            <option value="momentum">Momentum</option>
                            <option value="adam" selected>Adam</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label id="lr-opt-label">Learning Rate (Adam): <span class="value-display" id="lr-opt-value">0.010</span></label>
                        <input type="range" id="lr-opt-slider" min="0.0001" max="0.05" step="0.0001" value="0.01">
                        <div style="font-size: 0.8em; color: var(--distill-gray); margin-top: 5px;">
                            <span id="lr-range-hint">Recommended: 0.005 - 0.02</span>
                        </div>
                    </div>
                </div>
                <div style="text-align: center; margin: 20px 0;">
                    <button onclick="runOptimizer()">Run Optimizer</button>
                    <button onclick="resetToDefault()" style="background: #666; margin-left: 10px;">Reset to Default</button>
                </div>
                <div id="optimizer-plot" class="plot-container"></div>
                <div id="optimizer-info" style="font-family: 'Inter', sans-serif; font-size: 0.9em; margin-top: 15px;"></div>
            </div>

            <div class="callout">
                <div class="callout-title">Experiment with Learning Rates</div>
                <p>
                    Try different learning rates for each optimizer to understand their behavior:
                </p>
                <ul style="margin-left: 1.5em; line-height: 1.8;">
                    <li><strong>SGD</strong>: Too low → slow convergence; too high → oscillation or divergence. Recommended: 0.001-0.003</li>
                    <li><strong>Momentum</strong>: More stable than SGD, can handle slightly higher rates. Recommended: 0.0005-0.002</li>
                    <li><strong>Adam</strong>: Most robust, can handle much higher learning rates due to adaptive scaling. Recommended: 0.005-0.02</li>
                </ul>
            </div>
        </section>

        <section id="summary">
            <h2><span class="section-number">5.</span>Key Takeaways</h2>
            
            <div class="callout">
                <div class="callout-title">Essential Concepts</div>
                <ul style="margin-left: 1.5em; line-height: 1.8;">
                    <li><strong>Convexity guarantees global optimality:</strong> Convex problems are much easier to solve reliably.</li>
                    <li><strong>First-order methods dominate ML:</strong> Gradient descent and its variants are the workhorses of modern machine learning.</li>
                    <li><strong>Learning rate is critical:</strong> Too small means slow convergence; too large means instability.</li>
                    <li><strong>Advanced optimizers help:</strong> Momentum, Adam, and others can significantly speed up convergence.</li>
                    <li><strong>Constraints matter:</strong> Real-world problems often have constraints that must be respected.</li>
                </ul>
            </div>
        </section>
    </article>

    <footer>
        <p>
            <strong>Optimization Methods: An Interactive Guide</strong><br>
            Created for DA5400W - Foundations of Machine Learning<br>
            Dr. Arun B Ayyar, Indian Institute of Technology Madras<br>
            <br>
            Inspired by <a href="https://distill.pub" target="_blank" style="color: var(--distill-blue);">Distill.pub</a>
        </p>
    </footer>

    <script>
        // Linear function visualization
        function updateLinearPlot() {
            const c1 = parseFloat(document.getElementById('c1-slider').value);
            const c2 = parseFloat(document.getElementById('c2-slider').value);
            document.getElementById('c1-value').textContent = c1.toFixed(1);
            document.getElementById('c2-value').textContent = c2.toFixed(1);

            const x = [], y = [], z = [];
            for (let i = -5; i <= 5; i += 0.5) {
                const row_x = [], row_y = [], row_z = [];
                for (let j = -5; j <= 5; j += 0.5) {
                    row_x.push(i);
                    row_y.push(j);
                    row_z.push(c1 * i + c2 * j);
                }
                x.push(row_x);
                y.push(row_y);
                z.push(row_z);
            }

            const data = [{
                type: 'surface',
                x: x,
                y: y,
                z: z,
                colorscale: 'Viridis',
                showscale: false
            }];

            const layout = {
                scene: {
                    xaxis: {title: 'x₁'},
                    yaxis: {title: 'x₂'},
                    zaxis: {title: 'f(x)'},
                    camera: {
                        eye: {x: 1.5, y: 1.5, z: 1.3}
                    }
                },
                margin: {l: 0, r: 0, t: 0, b: 0},
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                height: 500
            };

            Plotly.newPlot('linear-plot', data, layout, {responsive: true});
        }

        // Convexity visualization
        function updateConvexPlot() {
            const lambda = parseFloat(document.getElementById('lambda-slider').value);
            document.getElementById('lambda-value').textContent = lambda.toFixed(2);

            const x1 = -1, x2 = 2;
            const f = x => x * x; // Simple quadratic
            const f1 = f(x1), f2 = f(x2);
            
            const x_interp = lambda * x1 + (1 - lambda) * x2;
            const f_interp = f(x_interp);
            const f_chord = lambda * f1 + (1 - lambda) * f2;

            const x_range = [];
            const y_range = [];
            for (let x = -2; x <= 3; x += 0.1) {
                x_range.push(x);
                y_range.push(f(x));
            }

            // Function curve
            const trace1 = {
                x: x_range,
                y: y_range,
                type: 'scatter',
                mode: 'lines',
                name: 'f(x) = x²',
                line: {color: '#004e89', width: 3}
            };

            // Chord connecting the two points
            const trace2 = {
                x: [x1, x2],
                y: [f1, f2],
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Chord (line segment)',
                line: {color: '#ff6b35', width: 2, dash: 'dash'},
                marker: {size: 10, color: '#ff6b35'}
            };

            // Vertical line showing the gap (convexity)
            const traceGap = {
                x: [x_interp, x_interp],
                y: [f_interp, f_chord],
                type: 'scatter',
                mode: 'lines',
                name: 'Convexity Gap',
                line: {color: 'rgba(0, 200, 0, 0.5)', width: 3},
                showlegend: true
            };

            // Point on the function
            const trace3 = {
                x: [x_interp],
                y: [f_interp],
                type: 'scatter',
                mode: 'markers+text',
                name: 'f(λx₁ + (1-λ)x₂)',
                marker: {size: 12, color: '#004e89', symbol: 'circle', line: {color: 'white', width: 2}},
                text: ['On curve'],
                textposition: 'bottom center',
                textfont: {size: 10}
            };

            // Point on the chord
            const trace4 = {
                x: [x_interp],
                y: [f_chord],
                type: 'scatter',
                mode: 'markers+text',
                name: 'λf(x₁) + (1-λ)f(x₂)',
                marker: {size: 12, color: '#ff6b35', symbol: 'square', line: {color: 'white', width: 2}},
                text: ['On chord'],
                textposition: 'top center',
                textfont: {size: 10}
            };

            // Shaded area showing convexity
            const traceShade = {
                x: [x_interp, x_interp],
                y: [0, f_interp],
                type: 'scatter',
                mode: 'lines',
                line: {color: 'rgba(0, 200, 0, 0.1)', width: 0},
                fill: 'tozeroy',
                fillcolor: 'rgba(0, 200, 0, 0.1)',
                showlegend: false,
                hoverinfo: 'skip'
            };

            const layout = {
                xaxis: {title: 'x', range: [-2, 3]},
                yaxis: {title: 'f(x)', range: [-0.5, 5]},
                showlegend: true,
                legend: {x: 0.02, y: 0.98},
                margin: {l: 50, r: 20, t: 20, b: 50},
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                hovermode: 'closest',
                height: 500,
                annotations: [
                    {
                        x: x_interp,
                        y: (f_interp + f_chord) / 2,
                        xref: 'x',
                        yref: 'y',
                        text: `Gap: ${(f_chord - f_interp).toFixed(3)}`,
                        showarrow: true,
                        arrowhead: 2,
                        arrowsize: 1,
                        arrowwidth: 2,
                        arrowcolor: 'green',
                        ax: 40,
                        ay: 0,
                        font: {size: 12, color: 'green'}
                    }
                ]
            };

            Plotly.newPlot('convex-plot', [trace1, trace2, traceGap, trace3, trace4], layout, {responsive: true});
        }

        // Profit function visualization
        function plotProfitFunction() {
            const x = [], y = [];
            for (let i = 0; i <= 4000; i += 20) {
                x.push(i);
                y.push(1000000 + 4000 * i - i * i);
            }

            const trace = {
                x: x,
                y: y,
                type: 'scatter',
                mode: 'lines',
                name: 'Profit Function',
                line: {color: '#004e89', width: 3}
            };

            const optimal = {
                x: [2000],
                y: [1000000 + 4000 * 2000 - 2000 * 2000],
                type: 'scatter',
                mode: 'markers',
                name: 'Optimal Point',
                marker: {size: 15, color: '#ff6b35', symbol: 'star'}
            };

            const layout = {
                xaxis: {title: 'x (units produced)'},
                yaxis: {title: 'Profit ($)'},
                showlegend: true,
                margin: {l: 80, r: 20, t: 20, b: 50},
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                height: 500
            };

            Plotly.newPlot('profit-plot', [trace, optimal], layout, {responsive: true});
        }

        // Gradient descent on 2D function
        let gdPath = [];
        
        function quadratic2D(x, y) {
            return (x - 2) * (x - 2) + (y - 3) * (y - 3);
        }

        function gradient2D(x, y) {
            return [2 * (x - 2), 2 * (y - 3)];
        }

        function plotGDSurface() {
            const x = [], y = [], z = [];
            for (let i = -1; i <= 5; i += 0.2) {
                const row_x = [], row_y = [], row_z = [];
                for (let j = -1; j <= 6; j += 0.2) {
                    row_x.push(i);
                    row_y.push(j);
                    row_z.push(quadratic2D(i, j));
                }
                x.push(row_x);
                y.push(row_y);
                z.push(row_z);
            }

            const surface = {
                type: 'surface',
                x: x,
                y: y,
                z: z,
                colorscale: 'Viridis',
                showscale: false,
                opacity: 0.8
            };

            const pathTrace = {
                type: 'scatter3d',
                x: gdPath.map(p => p[0]),
                y: gdPath.map(p => p[1]),
                z: gdPath.map(p => quadratic2D(p[0], p[1])),
                mode: 'lines+markers',
                name: 'GD Path',
                line: {color: '#ff6b35', width: 4},
                marker: {size: 4, color: '#ff6b35'}
            };

            const data = gdPath.length > 0 ? [surface, pathTrace] : [surface];

            const layout = {
                scene: {
                    xaxis: {title: 'x₁'},
                    yaxis: {title: 'x₂'},
                    zaxis: {title: 'f(x)'},
                    camera: {
                        eye: {x: 1.5, y: 1.5, z: 1.3}
                    }
                },
                margin: {l: 0, r: 0, t: 0, b: 0},
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                height: 500
            };

            Plotly.newPlot('gd-plot', data, layout, {responsive: true});
        }

        function runGradientDescent() {
            const lr = parseFloat(document.getElementById('lr-slider').value);
            const startX = parseFloat(document.getElementById('startx-slider').value);
            const startY = parseFloat(document.getElementById('starty-slider').value);

            let x = startX, y = startY;
            gdPath = [[x, y]];

            for (let i = 0; i < 50; i++) {
                const grad = gradient2D(x, y);
                x = x - lr * grad[0];
                y = y - lr * grad[1];
                gdPath.push([x, y]);

                if (Math.abs(grad[0]) < 0.001 && Math.abs(grad[1]) < 0.001) {
                    break;
                }
            }

            plotGDSurface();
            
            const finalLoss = quadratic2D(x, y);
            document.getElementById('gd-info').innerHTML = 
                `<strong>Converged in ${gdPath.length} iterations</strong><br>` +
                `Final position: (${x.toFixed(3)}, ${y.toFixed(3)})<br>` +
                `Final loss: ${finalLoss.toFixed(6)}`;
        }

        function resetGradientDescent() {
            gdPath = [];
            plotGDSurface();
            document.getElementById('gd-info').innerHTML = '';
        }

        // Linear programming visualization
        function plotLinearProgramming() {
            // Feasible region
            const x1_vals = [];
            const x2_vals = [];
            
            // Generate feasible region points
            for (let x1 = 0; x1 <= 50; x1 += 0.5) {
                const x2_max = Math.min(100 - 2*x1, 80 - x1);
                if (x2_max >= 0) {
                    x1_vals.push(x1);
                    x2_vals.push(x2_max);
                }
            }

            const feasible = {
                x: x1_vals,
                y: x2_vals,
                fill: 'tozeroy',
                fillcolor: 'rgba(255, 107, 53, 0.2)',
                line: {color: 'rgba(255, 107, 53, 0)'},
                name: 'Feasible Region',
                type: 'scatter'
            };

            // Constraints
            const x_range = Array.from({length: 101}, (_, i) => i);
            const constraint1 = {
                x: x_range,
                y: x_range.map(x => 100 - 2*x),
                mode: 'lines',
                name: '2x₁ + x₂ = 100',
                line: {color: '#004e89', width: 2}
            };

            const constraint2 = {
                x: x_range,
                y: x_range.map(x => 80 - x),
                mode: 'lines',
                name: 'x₁ + x₂ = 80',
                line: {color: '#00a8e8', width: 2}
            };

            // Optimal point
            const optimal = {
                x: [20],
                y: [60],
                mode: 'markers',
                name: 'Optimal (20, 60)',
                marker: {size: 15, color: '#ff6b35', symbol: 'star'}
            };

            const layout = {
                xaxis: {title: 'x₁ (Product 1)', range: [0, 100]},
                yaxis: {title: 'x₂ (Product 2)', range: [0, 100]},
                showlegend: true,
                legend: {x: 0.6, y: 0.95},
                margin: {l: 60, r: 20, t: 20, b: 50},
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                height: 500
            };

            Plotly.newPlot('lp-plot', [feasible, constraint1, constraint2, optimal], layout, {responsive: true});
        }

        // Optimizer comparison
        function runOptimizer() {
            const optimizer = document.getElementById('optimizer-select').value;
            
            // Rosenbrock function for testing
            function rosenbrock(x, y) {
                return (1 - x) ** 2 + 100 * (y - x ** 2) ** 2;
            }

            function rosenbrockGrad(x, y) {
                const dx = -2 * (1 - x) - 400 * x * (y - x ** 2);
                const dy = 200 * (y - x ** 2);
                return [dx, dy];
            }

            let x = -1.2, y = 1.0;
            const path = [[x, y]];
            
            // Get learning rate from slider
            const lr = parseFloat(document.getElementById('lr-opt-slider').value);
            
            let vx = 0, vy = 0; // For momentum
            let mx = 0, my = 0, vx2 = 0, vy2 = 0; // For Adam
            const beta1 = 0.9, beta2 = 0.999, epsilon = 1e-8;

            for (let i = 0; i < 2000; i++) {
                const [gx, gy] = rosenbrockGrad(x, y);

                if (optimizer === 'sgd') {
                    x -= lr * gx;
                    y -= lr * gy;
                } else if (optimizer === 'momentum') {
                    const momentum = 0.9;
                    vx = momentum * vx - lr * gx;
                    vy = momentum * vy - lr * gy;
                    x += vx;
                    y += vy;
                } else if (optimizer === 'adam') {
                    mx = beta1 * mx + (1 - beta1) * gx;
                    my = beta1 * my + (1 - beta1) * gy;
                    vx2 = beta2 * vx2 + (1 - beta2) * gx * gx;
                    vy2 = beta2 * vy2 + (1 - beta2) * gy * gy;
                    
                    const mx_hat = mx / (1 - Math.pow(beta1, i + 1));
                    const my_hat = my / (1 - Math.pow(beta1, i + 1));
                    const vx2_hat = vx2 / (1 - Math.pow(beta2, i + 1));
                    const vy2_hat = vy2 / (1 - Math.pow(beta2, i + 1));
                    
                    x -= lr * mx_hat / (Math.sqrt(vx2_hat) + epsilon);
                    y -= lr * my_hat / (Math.sqrt(vy2_hat) + epsilon);
                }

                path.push([x, y]);
            }

            // Plot contour with path
            const x_range = [];
            const y_range = [];
            const z_range = [];
            
            // Create proper grid for contour plot
            for (let i = -2; i <= 2; i += 0.1) {
                x_range.push(i);
            }
            for (let j = -1; j <= 3; j += 0.1) {
                y_range.push(j);
            }
            
            // Create 2D array for z values
            for (let j = 0; j < y_range.length; j++) {
                const row = [];
                for (let i = 0; i < x_range.length; i++) {
                    row.push(Math.log(rosenbrock(x_range[i], y_range[j]) + 1));
                }
                z_range.push(row);
            }

            const contour = {
                type: 'contour',
                x: x_range,
                y: y_range,
                z: z_range,
                colorscale: 'Viridis',
                showscale: false,
                contours: {
                    coloring: 'heatmap'
                }
            };

            const pathTrace = {
                x: path.map(p => p[0]),
                y: path.map(p => p[1]),
                mode: 'lines+markers',
                name: 'Optimization Path',
                line: {color: '#ff6b35', width: 2},
                marker: {size: 3, color: '#ff6b35'}
            };

            const optimalPoint = {
                x: [1],
                y: [1],
                mode: 'markers',
                name: 'Global Minimum',
                marker: {size: 15, color: 'white', symbol: 'star', line: {color: '#ff6b35', width: 2}}
            };

            const layout = {
                xaxis: {title: 'x'},
                yaxis: {title: 'y'},
                showlegend: true,
                margin: {l: 60, r: 20, t: 20, b: 50},
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                height: 500
            };

            Plotly.newPlot('optimizer-plot', [contour, pathTrace, optimalPoint], layout, {responsive: true});

            const finalLoss = rosenbrock(x, y);
            const distance = Math.sqrt((x - 1) ** 2 + (y - 1) ** 2);
            
            let converged = distance < 0.01 ? '✓ Converged!' : '✗ Not fully converged';
            let convergedColor = distance < 0.01 ? 'color: green;' : 'color: orange;';
            
            document.getElementById('optimizer-info').innerHTML = 
                `<strong>${optimizer.toUpperCase()} Results:</strong><br>` +
                `Final position: (${x.toFixed(4)}, ${y.toFixed(4)})<br>` +
                `Final loss: ${finalLoss.toFixed(6)}<br>` +
                `Distance from optimum: ${distance.toFixed(6)}<br>` +
                `<span style="${convergedColor}"><strong>${converged}</strong></span><br>` +
                `Iterations: 2000`;
        }

        // Learning rate control functions
        const defaultLearningRates = {
            'sgd': 0.002,
            'momentum': 0.001,
            'adam': 0.01
        };

        const learningRateRanges = {
            'sgd': { min: 0.0001, max: 0.01, recommended: '0.001 - 0.003' },
            'momentum': { min: 0.0001, max: 0.01, recommended: '0.0005 - 0.002' },
            'adam': { min: 0.0001, max: 0.05, recommended: '0.005 - 0.02' }
        };

        function updateLearningRateControl() {
            const optimizer = document.getElementById('optimizer-select').value;
            const slider = document.getElementById('lr-opt-slider');
            const label = document.getElementById('lr-opt-label');
            const hint = document.getElementById('lr-range-hint');
            
            const range = learningRateRanges[optimizer];
            slider.min = range.min;
            slider.max = range.max;
            slider.value = defaultLearningRates[optimizer];
            
            const optimizerName = optimizer.toUpperCase();
            label.innerHTML = `Learning Rate (${optimizerName}): <span class="value-display" id="lr-opt-value">${slider.value}</span>`;
            hint.textContent = `Recommended: ${range.recommended}`;
        }

        function resetToDefault() {
            const optimizer = document.getElementById('optimizer-select').value;
            const slider = document.getElementById('lr-opt-slider');
            slider.value = defaultLearningRates[optimizer];
            document.getElementById('lr-opt-value').textContent = slider.value;
        }

        // Update learning rate display when slider moves
        document.getElementById('lr-opt-slider').addEventListener('input', function() {
            document.getElementById('lr-opt-value').textContent = parseFloat(this.value).toFixed(4);
        });

        // Event listeners
        document.getElementById('c1-slider').addEventListener('input', updateLinearPlot);
        document.getElementById('c2-slider').addEventListener('input', updateLinearPlot);
        document.getElementById('lambda-slider').addEventListener('input', updateConvexPlot);
        
        document.getElementById('lr-slider').addEventListener('input', function() {
            document.getElementById('lr-value').textContent = this.value;
        });
        document.getElementById('startx-slider').addEventListener('input', function() {
            document.getElementById('startx-value').textContent = this.value;
        });
        document.getElementById('starty-slider').addEventListener('input', function() {
            document.getElementById('starty-value').textContent = this.value;
        });

        // Initialize plots
        window.addEventListener('load', function() {
            updateLinearPlot();
            updateConvexPlot();
            plotProfitFunction();
            plotGDSurface();
            plotLinearProgramming();
            runOptimizer();
        });

        // Animate gradient descent on profit function
        let animationRunning = false;
        function animateGradientDescent() {
            if (animationRunning) return;
            animationRunning = true;

            const button = event.target;
            button.disabled = true;
            button.textContent = 'Animating...';

            let x = 500;
            const lr = 0.4; // Smaller learning rate for stable convergence
            const path_x = [x];
            const path_y = [1000000 + 4000 * x - x * x];
            let iteration = 0;

            const interval = setInterval(() => {
                const grad = 4000 - 2 * x; // Derivative of profit function
                x = x + lr * grad; // Gradient ascent for maximization
                iteration++;

                path_x.push(x);
                path_y.push(1000000 + 4000 * x - x * x);

                const x_range = [], y_range = [];
                for (let i = 0; i <= 4000; i += 20) {
                    x_range.push(i);
                    y_range.push(1000000 + 4000 * i - i * i);
                }

                const trace = {
                    x: x_range,
                    y: y_range,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Profit Function',
                    line: {color: '#004e89', width: 3}
                };

                const pathTrace = {
                    x: path_x,
                    y: path_y,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Gradient Ascent',
                    line: {color: '#ff6b35', width: 2},
                    marker: {size: 6}
                };

                const layout = {
                    xaxis: {title: 'x (units produced)'},
                    yaxis: {title: 'Profit ($)'},
                    showlegend: true,
                    margin: {l: 80, r: 20, t: 20, b: 50},
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    height: 500
                };

                // Add current point marker
                const currentPoint = {
                    x: [x],
                    y: [1000000 + 4000 * x - x * x],
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Current Position',
                    marker: {size: 12, color: '#ff6b35', symbol: 'circle', line: {color: 'white', width: 2}}
                };

                Plotly.newPlot('profit-plot', [trace, pathTrace, currentPoint], layout, {responsive: true});

                // Stop when converged or max iterations
                if (Math.abs(grad) < 1 || iteration > 50) {
                    clearInterval(interval);
                    
                    // Add optimal point marker
                    const optimalMarker = {
                        x: [2000],
                        y: [1000000 + 4000 * 2000 - 2000 * 2000],
                        type: 'scatter',
                        mode: 'markers',
                        name: 'Optimal (x=2000)',
                        marker: {size: 15, color: '#00a8e8', symbol: 'star'}
                    };
                    
                    Plotly.newPlot('profit-plot', [trace, pathTrace, currentPoint, optimalMarker], layout, {responsive: true});
                    
                    button.disabled = false;
                    button.textContent = 'Animate Gradient Descent';
                    animationRunning = false;
                }
            }, 150);
        }
    </script>
</body>
</html>
